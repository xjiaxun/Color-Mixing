from pump import *
import time
import math
import numpy as np
from threading import Timer
import seabreeze
from seabreeze.spectrometers import Spectrometer
from colormath.color_objects import SpectralColor, CMYColor, sRGBColor
from colormath.color_conversions import convert_color
from scipy import interpolate

def set_pump_rates(pumps, flowrates):
    ''' Set pump rates '''
    for index in range(len(pumps)):
        pumps[index].set_infuse_rate(flowrates[index])
        time.sleep(0.1)


def infuse_all(pumps):
    ''' Start infusion on all connected pumps'''
    for pump in pumps:
        pump.infuse()
        time.sleep(0.1)

def stop_all(pumps):
    ''' Start infusion on all connected pumps'''
    for pump in pumps:
        pump.stop()
        time.sleep(0.1)

def calc_time_to_travel(flowrates, tube_dist, tube_dia, extra=15):
    ''' Calculate waiting time (sec) for new condition generated by pumps to reach spectrograph
        extra length for flowrates to continue
        flowrates unit: [ul/min] 
        tube_dist unit: [mm]
        tube_dia unit:  [mm]
    '''
    time_to_travel = tube_dist*(math.pi*(tube_dia/2)**2)/(sum(flowrates))*60 \
        + extra
        #+ 50*(math.pi*(1/2)**2)/(sum(flowrates))*60  \

    print("Time to travel (sec): "+str(time_to_travel))
    return time_to_travel

def small_step_Q(flowrates, step_size):
    ''' generate flowrates matrix with a fixed scout step size '''
    small_steps= np.empty(shape=(4,4),dtype='object')
    flowrates = np.asarray(flowrates)
    small_steps = flowrates + np.diag([step_size]*4)
    return small_steps

def random_small_step_Q(flowrates):
    ''' generate flowrates matrix with random scout step sizes '''
    small_steps= np.empty(shape=(4,4),dtype='object')
    flowrates = np.asarray(flowrates)
    step_sizes = np.random.choice(np.arange(15,51),4)
    small_steps = flowrates + np.diag(step_sizes)
    return small_steps


class AcquireData():
    ''' functions to acquire one data point '''

    def __init__(self, pumps, rates, tube_dist, tube_dia, spec, ref_intensities, bg_intensities, wavelengths,\
    no_of_avg, logger, diffuse_time=60):
        self.pumps = pumps
        self.rates = rates
        self.tube_dist = tube_dist
        self.tube_dia = tube_dia
        self.spec = spec
        self.ref_intensities = ref_intensities
        self.bg_intensities = bg_intensities
        self.wavelengths = wavelengths
        self.no_of_avg = no_of_avg
        self.logger = logger
        self.diffuse_time = diffuse_time
        self.rgb_avg = []
        self.wait_sec = 0 # wait for running condition flow rates

    

    def to_transmittance(self, intensities, ref_intensities, bg_intensities):
        ''' Calculate transmittance within the range 0-1'''
        transmittance = (intensities-bg_intensities)/(ref_intensities-bg_intensities)
        # ignore transmittance out of range [0,1], which is due to noise
        transmittance[transmittance>1]=1
        transmittance[transmittance<0]=0
        return transmittance

    def transm_to_rgb(self, wavelengths,transmittance):
        ''' Convert transmittance to rgb 0-255 '''
        f = interpolate.interp1d(wavelengths,transmittance)
        # colormath only accepts wavelength in the following format (some info is lost in this step)
        wavelengths_new = np.arange(340, 840, 10) 
        transmittance_new = f(wavelengths_new)
        spectral = SpectralColor(*transmittance_new,observer='10')
        rgb = convert_color(spectral, sRGBColor).get_upscaled_value_tuple()
        rgb = np.asarray(rgb)
        rgb[rgb>255]=255
        return rgb

    def run_one_cond(self):
        # Run pumps at the condition rates until the zcell for uv-vis is filled
        # ==> Triggers diffuse_cond() after pump_timer timed out
        set_pump_rates(self.pumps, self.rates)
        infuse_all(self.pumps)
        self.wait_sec = calc_time_to_travel(self.rates, self.tube_dist, self.tube_dia)
        #print('Start infusing with flow rates '+str(rates)+' for '+str(wait_sec)+' seconds')
        self.logger.log('log','Start infusing with flow rates '+str(self.rates)+' for '+str(self.wait_sec)+' seconds')
        #self.pump_timer = Timer(self.wait_sec, self.diffuse_cond)
        self.pump_timer = Timer(self.wait_sec, self.take_spec) # take scan immediately, never stop pumping
        self.pump_timer.start()

    def diffuse_cond(self):
        # Stop pumps and wait for diffusion
        # ==> Triggers pump2spec() after diffuse_timer timed out (won't trigger if diffuse_time == 0)
        stop_all(self.pumps)
        #print('Wait for diffusion time:  '+str(diffuse_time)+' seconds')
        self.logger.log('log','Wait for diffusion time:  '+str(self.diffuse_time)+' seconds')
        #self.diffuse_timer = Timer(self.diffuse_time, self.pump2spec)
        self.diffuse_timer = Timer(self.diffuse_time, self.take_spec)
        self.diffuse_timer.start() # skipped if diffuse_time == 0

    def pump2spec(self):
        # Slow flow for uv-vis to acquire spectra. (Skipped if diffuse_time == 0)
        # ==> Triggers take_spec() after pump2spec_timer timed out
        set_pump_rates(self.pumps, [25,25,25,25])
        infuse_all(self.pumps)
        #print('Start acquiring spectra...\n')
        self.logger.log('log','Acquiring spectrograph...')
        self.pump2spec_timer = Timer(3, self.take_spec)
        self.pump2spec_timer.start()
    
    def take_spec(self):
        # take spectra, average and convert to RGB
        
        intens_sum = np.zeros(len(self.ref_intensities))
        
        for i in range(self.no_of_avg):
            intensities = self.spec.spectrum()[1]
            
            # save spectrum
            self.logger.save_data('spec',intensities) # save to local
            self.logger.log('log','Capcutred and saved spectrum')


            # derive transmittance
            transmittance = self.to_transmittance(intensities, self.ref_intensities, self.bg_intensities)
            self.logger.save_data('trans',transmittance) # save to local
            # convert to rgb
            rgb = self.transm_to_rgb(self.wavelengths, transmittance)
            print("RGB: "+str(rgb))
            self.logger.log('log','Converted to RGB: '+str(rgb))

            # sum intensities array
            intens_sum += intensities
            # delay for next measurement
            #time.sleep(1)
        # average the 5 intensities spectra
        intens_avg = intens_sum/self.no_of_avg
        # save averaged intensities
        self.logger.save_data('avgspec',intens_avg) # save to local
        # find rgb of averaged intensities spectra
        transmittance = self.to_transmittance(intens_avg, self.ref_intensities, self.bg_intensities)
        # save averaged transmittance
        self.logger.save_data('avgtrans',transmittance) # save to local
        self.rgb_avg = self.transm_to_rgb(self.wavelengths, transmittance)
        print('RGB of average intensities spectra is '+str(self.rgb_avg))
        self.logger.log('log','Averaged Intensities Spectra RGB: '+str(self.rgb_avg))
        self.logger.log('rgb',str(self.rgb_avg))



    def stop_timer(self):
        ''' Stop any currently running timer if user click stop from the UI '''
        try:
            self.pump_timer.cancel()
            self.diffuse_timer.cancel()
            self.pump2spec_timer.cancel()
        except Exception:
            pass


# ------------------- Above is cleaned ---------------------------------------

